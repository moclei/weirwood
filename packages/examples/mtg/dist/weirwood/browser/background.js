var G=Object.create;var U=Object.defineProperty;var H=Object.getOwnPropertyDescriptor;var Z=Object.getOwnPropertyNames;var J=Object.getPrototypeOf,V=Object.prototype.hasOwnProperty;var Q=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var X=(t,e,n,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let h of Z(e))!V.call(t,h)&&h!==n&&U(t,h,{get:()=>e[h],enumerable:!(o=H(e,h))||o.enumerable});return t};var F=(t,e,n)=>(n=t!=null?G(J(t)):{},X(e||!t||!t.__esModule?U(n,"default",{value:t,enumerable:!0}):n,t));var E=Q((P,_)=>{(function(t,e){if(typeof define=="function"&&define.amd)define("webextension-polyfill",["module"],e);else if(typeof P<"u")e(_);else{var n={exports:{}};e(n),t.browser=n.exports}})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:P,function(t){"use strict";if(!globalThis.chrome?.runtime?.id)throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){let e="The message port closed before a response was received.",n=o=>{let h={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(h).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class M extends WeakMap{constructor(r,i=void 0){super(i),this.createItem=r}get(r){return this.has(r)||this.set(r,this.createItem(r)),super.get(r)}}let D=s=>s&&typeof s=="object"&&typeof s.then=="function",L=(s,r)=>(...i)=>{o.runtime.lastError?s.reject(new Error(o.runtime.lastError.message)):r.singleCallbackArg||i.length<=1&&r.singleCallbackArg!==!1?s.resolve(i[0]):s.resolve(i)},f=s=>s==1?"argument":"arguments",q=(s,r)=>function(g,...l){if(l.length<r.minArgs)throw new Error(`Expected at least ${r.minArgs} ${f(r.minArgs)} for ${s}(), got ${l.length}`);if(l.length>r.maxArgs)throw new Error(`Expected at most ${r.maxArgs} ${f(r.maxArgs)} for ${s}(), got ${l.length}`);return new Promise((c,A)=>{if(r.fallbackToNoCallback)try{g[s](...l,L({resolve:c,reject:A},r))}catch(a){console.warn(`${s} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,a),g[s](...l),r.fallbackToNoCallback=!1,r.noCallback=!0,c()}else r.noCallback?(g[s](...l),c()):g[s](...l,L({resolve:c,reject:A},r))})},O=(s,r,i)=>new Proxy(r,{apply(g,l,c){return i.call(l,s,...c)}}),b=Function.call.bind(Object.prototype.hasOwnProperty),y=(s,r={},i={})=>{let g=Object.create(null),l={has(A,a){return a in s||a in g},get(A,a,d){if(a in g)return g[a];if(!(a in s))return;let m=s[a];if(typeof m=="function")if(typeof r[a]=="function")m=O(s,s[a],r[a]);else if(b(i,a)){let x=q(a,i[a]);m=O(s,s[a],x)}else m=m.bind(s);else if(typeof m=="object"&&m!==null&&(b(r,a)||b(i,a)))m=y(m,r[a],i[a]);else if(b(i,"*"))m=y(m,r[a],i["*"]);else return Object.defineProperty(g,a,{configurable:!0,enumerable:!0,get(){return s[a]},set(x){s[a]=x}}),m;return g[a]=m,m},set(A,a,d,m){return a in g?g[a]=d:s[a]=d,!0},defineProperty(A,a,d){return Reflect.defineProperty(g,a,d)},deleteProperty(A,a){return Reflect.deleteProperty(g,a)}},c=Object.create(s);return new Proxy(c,l)},C=s=>({addListener(r,i,...g){r.addListener(s.get(i),...g)},hasListener(r,i){return r.hasListener(s.get(i))},removeListener(r,i){r.removeListener(s.get(i))}}),W=new M(s=>typeof s!="function"?s:function(i){let g=y(i,{},{getContent:{minArgs:0,maxArgs:0}});s(g)}),N=new M(s=>typeof s!="function"?s:function(i,g,l){let c=!1,A,a=new Promise(p=>{A=function(S){c=!0,p(S)}}),d;try{d=s(i,g,A)}catch(p){d=Promise.reject(p)}let m=d!==!0&&D(d);if(d!==!0&&!m&&!c)return!1;let x=p=>{p.then(S=>{l(S)},S=>{let T;S&&(S instanceof Error||typeof S.message=="string")?T=S.message:T="An unexpected error occurred",l({__mozWebExtensionPolyfillReject__:!0,message:T})}).catch(S=>{console.error("Failed to send onMessage rejected reply",S)})};return x(m?d:a),!0}),K=({reject:s,resolve:r},i)=>{o.runtime.lastError?o.runtime.lastError.message===e?r():s(new Error(o.runtime.lastError.message)):i&&i.__mozWebExtensionPolyfillReject__?s(new Error(i.message)):r(i)},R=(s,r,i,...g)=>{if(g.length<r.minArgs)throw new Error(`Expected at least ${r.minArgs} ${f(r.minArgs)} for ${s}(), got ${g.length}`);if(g.length>r.maxArgs)throw new Error(`Expected at most ${r.maxArgs} ${f(r.maxArgs)} for ${s}(), got ${g.length}`);return new Promise((l,c)=>{let A=K.bind(null,{resolve:l,reject:c});g.push(A),i.sendMessage(...g)})},z={devtools:{network:{onRequestFinished:C(W)}},runtime:{onMessage:C(N),onMessageExternal:C(N),sendMessage:R.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:R.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},k={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return h.privacy={network:{"*":k},services:{"*":k},websites:{"*":k}},y(o,z,h)};t.exports=n(chrome)}else t.exports=globalThis.browser})});var u=F(E());var B={stats:{active:0,open:0},version:"",magicCard:null,ports:[]};var v=F(E()),Y={stats:{active:0,open:0},version:"",magicCard:null,ports:[]},j=class{constructor(t,e){this.storageKey=t,this.instanceStates={},this.onStateChangeListeners=[],this.state=e,this.loadStateFromStorage()}async loadStateFromStorage(){console.log("Loading state from storage");let t=await v.default.storage.local.get(this.storageKey);if(t[this.storageKey]){let e=JSON.parse(t[this.storageKey]),{instanceStates:n,...o}=e;this.state=o,this.instanceStates=n,this.notifyStateChange()}}async saveStateToStorage(){console.log("saveStateToStorage");let t=JSON.stringify({...this.state,instanceStates:{...this.instanceStates}});await v.default.storage.local.set({[this.storageKey]:t})}getState(){return this.state}async setState(t){this.state={...this.state,...t},await this.saveStateToStorage(),this.notifyStateChange()}getAppState(t){return console.log("Getting app state for tabId: ",t),{...this.state,...this.instanceStates[t]}}async setAppState(t,e){this.instanceStates={...this.instanceStates,[e]:{...this.instanceStates[e],...t}},await this.saveStateToStorage(),this.notifyStateChange()}async removeInstance(t){this.instanceStates.hasOwnProperty(t)&&(console.log("stateSyncService.removeInstance, deleting instance state."),delete this.instanceStates[t]),await this.saveStateToStorage(),this.notifyStateChange()}async clearState(){console.log("Clearing state"),this.state={...Y,version:v.default.runtime.getManifest().version},this.instanceStates={},await this.saveStateToStorage(),this.notifyStateChange()}onStateChange(t){this.onStateChangeListeners.push(t)}getInstanceOpenStates(){let t=[];for(let[e,n]of Object.entries(this.instanceStates)){let o=Number(e);isNaN(o)||t.push({port:o,isOpen:n.isOpen})}return t}notifyStateChange(){let t=this.getInstanceOpenStates().filter(n=>n.isOpen).length,e=Object.keys(this.instanceStates).map(n=>({tabId:n,isOpen:this.instanceStates[Number(n)].isOpen}));this.state={...this.state,stats:{...this.state.stats,open:t},ports:e},this.onStateChangeListeners.forEach(n=>n(this.state))}},$=class{constructor(t){this.ports={},this.stateSyncService=t,this.stateSyncService.onStateChange(e=>{this.broadcastStateUpdate(e)})}addPort(t,e,n){this.ports[t]=n,this.stateSyncService.setAppState({tabUrl:e,tabId:t,initialized:new Date().getTime().toString()},t);let o=this.stateSyncService.getState();this.stateSyncService.setState({stats:{...o.stats,active:Object.keys(this.ports).length}}),n.onMessage.addListener(h=>this.handleMessage(t,h)),n.onDisconnect.addListener(()=>{console.log("Ports disconnected. tabId: ",t),delete this.ports[t],this.stateSyncService.removeInstance(t)}),this.sendStateUpdate(t)}handleMessage(t,e){e.type==="setState"&&(console.log("handleMessage, setState"),this.stateSyncService.setAppState(e.state,t)),e.type==="setInstanceState"&&(console.log("handleMessage, setInstanceState"),this.stateSyncService.setAppState(e.state,e.tabId))}sendStateUpdate(t){this.ports[t]?this.ports[t].postMessage({type:"stateUpdate",state:{...this.stateSyncService.getAppState(t)}}):console.log("sendStateUpdate: No port for tabId: ",t," yet.")}broadcastStateUpdate(t){console.log("Broadcasting state update"),Object.keys(this.ports).forEach(e=>{this.sendStateUpdate(Number(e))})}};var w=class{constructor(e){this.stateSyncService=e}async handleFetchRequest(e){try{let n=await fetch(e.url,{method:e.method,headers:e.headers,body:e.body});if(n.ok){let o=await n.json();e.type==="card"&&this.stateSyncService.setState({...this.stateSyncService.getState(),magicCard:o})}else console.error("HTTP request failed:",n.status)}catch(n){console.error("Error occurred during HTTP request:",n)}}};var I=class{constructor(){console.log("Hello"),console.log("background script constructor called"),this.stateSyncService=new j("BackgroundState",{...B,version:u.default.runtime.getManifest().version}),this.httpService=new w(this.stateSyncService),this.portManager=new $(this.stateSyncService),this.establishListeners()}establishListeners(){u.default.action.onClicked.addListener(e=>{u.default.tabs.sendMessage(e.id,{type:"toggleApp"})}),u.default.runtime.onConnect.addListener(e=>{if(e.name==="stateSyncChannel"){console.log("Connecting stateSyncChannel");let n=e.sender.tab.id,o=e.sender.tab.url;this.portManager.addPort(n,o,e)}e.name==="fetchChannel"&&(console.log("Connecting fetchChannel"),e.onMessage.addListener(n=>{this.httpService.handleFetchRequest(n)}))}),u.default.runtime.onInstalled.addListener(e=>{console.log("onInstalled listener heard. details: ",e),e.reason==="install"&&this.stateSyncService.clearState(),e.reason==="update"&&this.stateSyncService.clearState()}),u.default.runtime.onStartup.addListener(()=>{console.log("onStartup listener heard.")}),u.default.runtime.onSuspend.addListener(()=>{console.log("onSuspend listener heard.")}),u.default.runtime.onSuspendCanceled.addListener(()=>{console.log("onSuspendCanceled listener heard.")}),u.default.runtime.onUpdateAvailable.addListener(()=>{console.log("onUpdateAvailable listener heard.")})}};new I;
//# sourceMappingURL=background.js.map
