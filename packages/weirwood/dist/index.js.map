{
  "version": 3,
  "sources": ["../src/state-service.ts", "../src/app.state.ts", "../src/port-service.ts"],
  "sourcesContent": ["import browser from 'webextension-polyfill';\nimport { AngularState, INITIAL_BACKGROUND_STATE, PortState, StorageState } from './app.state';\n\nexport class StateSyncService<T extends StorageState> {\n    private state: T;\n    private instanceStates: PortState = {};\n    private onStateChangeListeners: Array<(state: T) => void> = [];\n\n    constructor(private readonly storageKey: string, initialState: T) {\n        this.state = initialState;\n        this.loadStateFromStorage();\n    }\n\n    private async loadStateFromStorage(): Promise<void> {\n        console.log('Loading state from storage');\n        const storedState = await browser.storage.local.get(this.storageKey);\n        if (storedState[this.storageKey]) {\n            const allStates = JSON.parse(storedState[this.storageKey]);\n            const { instanceStates, ...state } = allStates;\n            this.state = state;\n            this.instanceStates = instanceStates;\n            this.notifyStateChange();\n        }\n    }\n\n    private async saveStateToStorage(): Promise<void> {\n        console.log('saveStateToStorage');\n        const persistState = JSON.stringify({ ...this.state, instanceStates: { ...this.instanceStates } });\n        await browser.storage.local.set({ [this.storageKey]: persistState });\n    }\n\n    public getState(): T {\n        return this.state;\n    }\n\n    public async setState(newState: Partial<T>): Promise<void> {\n        this.state = { ...this.state, ...newState };\n        await this.saveStateToStorage();\n        this.notifyStateChange();\n    }\n\n    public getAppState(tabId: number): T {\n        console.log('Getting app state for tabId: ', tabId);\n        return { ...this.state, ...this.instanceStates[tabId] };\n    }\n\n    public async setAppState(newState: Partial<AngularState>, tabId: number): Promise<void> {\n        this.instanceStates = { ...this.instanceStates, [tabId]: { ...this.instanceStates[tabId], ...newState } };\n        await this.saveStateToStorage();\n        this.notifyStateChange();\n    }\n\n    public async removeInstance(tabId: number): Promise<void> {\n        if (this.instanceStates.hasOwnProperty(tabId)) {\n            console.log('stateSyncService.removeInstance, deleting instance state.')\n            delete this.instanceStates[tabId];\n        }\n        await this.saveStateToStorage();\n        this.notifyStateChange();\n    }\n\n    public async clearState(): Promise<void> {\n        console.log('Clearing state');\n        this.state = {\n            ...INITIAL_BACKGROUND_STATE,\n            version: browser.runtime.getManifest().version,\n        } as T;\n        this.instanceStates = {};\n        await this.saveStateToStorage();\n        this.notifyStateChange();\n    }\n\n    public onStateChange(listener: (state: T) => void): void {\n        this.onStateChangeListeners.push(listener);\n    }\n\n    public getInstanceOpenStates(): { port: number, isOpen: boolean }[] {\n        const result: Array<{ port: number, isOpen: boolean }> = [];\n\n        for (const [key, value] of Object.entries(this.instanceStates)) {\n            const portNumber = Number(key);\n            if (!isNaN(portNumber)) {\n                result.push({ port: portNumber, isOpen: value.isOpen });\n            }\n        }\n\n        return result;\n    }\n\n    private notifyStateChange(): void {\n        // Update computed state properties. Could pass these in as handler functions to the constructor.\n        const numOpen = this.getInstanceOpenStates().filter(state => state.isOpen).length;\n        const ports = Object.keys(this.instanceStates).map((key: string) => {\n            return { tabId: key, isOpen: this.instanceStates[Number(key)].isOpen }\n        });\n        this.state = { ...this.state, stats: { ...this.state.stats, open: numOpen }, ports: ports };\n        // Todo: we pass in this.state to the listener, but the broadcast function that uses it just calls getState(). \n        // Do one or the other.\n        this.onStateChangeListeners.forEach(listener => listener(this.state));\n    }\n}\n", "export interface BackgroundState {\n    stats: {\n        active: number;\n        open: number;\n    };\n    version: string;\n    magicCard: any;\n    ports: Instance[];\n}\nexport interface Instance {\n    isOpen: boolean;\n    tabId: number;\n}\n\nexport interface AngularState {\n    url: string;\n    clicks: number;\n    isOpen: boolean;\n    tabUrl: string;\n    tabId: number;\n    initialized: string;\n}\n\nexport interface PortState {\n    [key: number]: AngularState;\n}\n\n\nexport type StorageState = BackgroundState & PortState;\n\nexport type AppState = BackgroundState & AngularState;\n\nexport const INITIAL_BACKGROUND_STATE: BackgroundState = {\n    stats: {\n        active: 0,\n        open: 0\n    },\n    version: '',\n    magicCard: null,\n    ports: []\n}\nexport const INITIAL_APP_STATE: AngularState = {\n    url: '',\n    clicks: 0,\n    isOpen: false,\n    tabId: 0,\n    tabUrl: '',\n    initialized: '',\n}", "import browser from 'webextension-polyfill';\nimport { StateSyncService } from './state-service';\nimport { StorageState } from './app.state';\n\nexport class PortManager {\n    private ports: { [tabId: number]: browser.Runtime.Port } = {};\n    public stateSyncService: StateSyncService<StorageState>;\n\n    constructor(stateSyncService: StateSyncService<StorageState>) {\n        this.stateSyncService = stateSyncService;\n        this.stateSyncService.onStateChange((state: any) => {\n            this.broadcastStateUpdate(state);\n        });\n    }\n\n    public addPort(tabId: number, tabUrl: string, port: browser.Runtime.Port): void {\n        this.ports[tabId] = port;\n        this.stateSyncService.setAppState({ tabUrl, tabId, initialized: new Date().getTime().toString() }, tabId);\n        const state = this.stateSyncService.getState();\n        this.stateSyncService.setState({ stats: { ...state.stats, active: Object.keys(this.ports).length } });\n        port.onMessage.addListener(message => this.handleMessage(tabId, message));\n        port.onDisconnect.addListener(() => {\n            console.log('Ports disconnected. tabId: ', tabId);\n            delete this.ports[tabId];\n            this.stateSyncService.removeInstance(tabId);\n        });\n        this.sendStateUpdate(tabId);\n    }\n\n    private handleMessage(tabId: number, message: any): void {\n        if (message.type === 'setState') {\n            console.log('handleMessage, setState');\n            this.stateSyncService.setAppState(message.state, tabId);\n        }\n        if (message.type === 'setInstanceState') {\n            console.log('handleMessage, setInstanceState');\n            this.stateSyncService.setAppState(message.state, message.tabId);\n        }\n    }\n\n    private sendStateUpdate(tabId: number): void {\n        if (this.ports[tabId]) {\n            this.ports[tabId].postMessage({\n                type: 'stateUpdate',\n                state: {\n                    ...this.stateSyncService.getAppState(tabId),\n                }\n            });\n        } else {\n            console.log('sendStateUpdate: No port for tabId: ', tabId, ' yet.');\n        }\n    }\n\n    public broadcastStateUpdate(state: any): void {\n        console.log('Broadcasting state update');\n        Object.keys(this.ports).forEach(tabId => {\n            this.sendStateUpdate(Number(tabId))\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": ["browser", "INITIAL_BACKGROUND_STATE", "StateSyncService", "storageKey", "initialState", "storedState", "browser", "allStates", "instanceStates", "state", "persistState", "newState", "tabId", "INITIAL_BACKGROUND_STATE", "listener", "result", "key", "value", "portNumber", "numOpen", "ports", "PortManager", "stateSyncService", "state", "tabId", "tabUrl", "port", "message"]
}
