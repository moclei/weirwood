import n from"webextension-polyfill";var o={stats:{active:0,open:0},version:"",magicCard:null,ports:[]};var i=class{constructor(t,e){this.storageKey=t;this.instanceStates={};this.onStateChangeListeners=[];this.state=e,this.loadStateFromStorage()}async loadStateFromStorage(){console.log("Loading state from storage");let t=await n.storage.local.get(this.storageKey);if(t[this.storageKey]){let e=JSON.parse(t[this.storageKey]),{instanceStates:a,...s}=e;this.state=s,this.instanceStates=a,this.notifyStateChange()}}async saveStateToStorage(){console.log("saveStateToStorage");let t=JSON.stringify({...this.state,instanceStates:{...this.instanceStates}});await n.storage.local.set({[this.storageKey]:t})}getState(){return this.state}async setState(t){this.state={...this.state,...t},await this.saveStateToStorage(),this.notifyStateChange()}getAppState(t){return console.log("Getting app state for tabId: ",t),{...this.state,...this.instanceStates[t]}}async setAppState(t,e){this.instanceStates={...this.instanceStates,[e]:{...this.instanceStates[e],...t}},await this.saveStateToStorage(),this.notifyStateChange()}async removeInstance(t){this.instanceStates.hasOwnProperty(t)&&(console.log("stateSyncService.removeInstance, deleting instance state."),delete this.instanceStates[t]),await this.saveStateToStorage(),this.notifyStateChange()}async clearState(){console.log("Clearing state"),this.state={...o,version:n.runtime.getManifest().version},this.instanceStates={},await this.saveStateToStorage(),this.notifyStateChange()}onStateChange(t){this.onStateChangeListeners.push(t)}getInstanceOpenStates(){let t=[];for(let[e,a]of Object.entries(this.instanceStates)){let s=Number(e);isNaN(s)||t.push({port:s,isOpen:a.isOpen})}return t}notifyStateChange(){let t=this.getInstanceOpenStates().filter(a=>a.isOpen).length,e=Object.keys(this.instanceStates).map(a=>({tabId:a,isOpen:this.instanceStates[Number(a)].isOpen}));this.state={...this.state,stats:{...this.state.stats,open:t},ports:e},this.onStateChangeListeners.forEach(a=>a(this.state))}};var r=class{constructor(t){this.ports={};this.stateSyncService=t,this.stateSyncService.onStateChange(e=>{this.broadcastStateUpdate(e)})}addPort(t,e,a){this.ports[t]=a,this.stateSyncService.setAppState({tabUrl:e,tabId:t,initialized:new Date().getTime().toString()},t);let s=this.stateSyncService.getState();this.stateSyncService.setState({stats:{...s.stats,active:Object.keys(this.ports).length}}),a.onMessage.addListener(c=>this.handleMessage(t,c)),a.onDisconnect.addListener(()=>{console.log("Ports disconnected. tabId: ",t),delete this.ports[t],this.stateSyncService.removeInstance(t)}),this.sendStateUpdate(t)}handleMessage(t,e){e.type==="setState"&&(console.log("handleMessage, setState"),this.stateSyncService.setAppState(e.state,t)),e.type==="setInstanceState"&&(console.log("handleMessage, setInstanceState"),this.stateSyncService.setAppState(e.state,e.tabId))}sendStateUpdate(t){this.ports[t]?this.ports[t].postMessage({type:"stateUpdate",state:{...this.stateSyncService.getAppState(t)}}):console.log("sendStateUpdate: No port for tabId: ",t," yet.")}broadcastStateUpdate(t){console.log("Broadcasting state update"),Object.keys(this.ports).forEach(e=>{this.sendStateUpdate(Number(e))})}};export{r as PortManager,i as StateSyncService};
//# sourceMappingURL=index.js.map
